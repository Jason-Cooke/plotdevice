<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>

  <title>PlotDevice Libraries: Linguistics</title>
  <link charset="utf-8" href="../etc/manual.css" rel="stylesheet" type="text/css"/>

</head><body>
  <div class="link" id="nav">
    <h1><a href="../manual.html">Plot Device <span>Libraries</span></a></h1>

    <h3>Linguistics</h3>
  </div>

  <div class="article">
    <h2>Description</h2>

    <p>With the Nodebox English Linguistics library you can do grammar inflection and semantic
    operations on English content. You can use the library to conjugate verbs, pluralize nouns,
    write out numbers, find dictionary descriptions and synonyms for words, summarise texts and
    parse grammatical structure from sentences.</p>
    <p>The library bundles <a href="http://www.cogsci.princeton.edu/~wn/">WordNet</a> (using Oliver
    Steele’s <a href="http://osteele.com/projects/pywordnet/">PyWordNet</a>), <a href="http://nltk.sourceforge.net/">NLTK</a>, Damian Conway’s <a href="http://www.csse.monash.edu.au/~damian/papers/HTML/Plurals.html">pluralisation rules</a>, Bermi
    Ferrer’s <a href="http://www.bermi.org/inflector/">singularization rules</a>, Jason Wiener’s
    <a href="http://jasonwiener.wordpress.com/2006/01/20/simple-nlp-part-of-speech-tagger-in-python/">Brill
    tagger</a>, several algorithms adopted from Michael Granger’s <a href="http://www.deveiate.org/projects/Linguistics/wiki/English">Ruby Linguistics</a> module, John
    Wiseman’s implementation of the <a href="http://lemonodor.com/archives/001511.html">Regressive
    Imagery Dictionary</a>, Charles K. Ogden’s list of <a href="http://ogden.basic-english.org">basic English</a> words, and Peter Norvig’s <a href="http://norvig.com/spell-correct.html">spelling corrector</a>.<br/></p>
    <h2>Download</h2>

    <table border="0">
      <tbody>
        <tr>
          <td><a href="http://nodebox.net/code/data/media/linguistics.zip"><img alt="download" height="20" src="../etc/lib/download.gif" width="20"/></a>
          </td><td><a href="http://nodebox.net/code/data/media/linguistics.zip">linguistics.zip</a>
          (15MB)<br/>
          <i>Last updated for PlotDevice 1.9.4.2<br/></i><i>Licensed under GPL<br/>
          Author: Tom De Smedt<br/></i>
        </td></tr></tbody></table>

    <h2>Documentation</h2>

    <ul>
      <li><a href="#loading_the_library">How to get the library up and running</a></li>
      <li><a href="#lexical_categorisation">Categorise words as nouns, verbs, numbers and more</a></li>
      <li><a href="#commonsense">Categorise words as emotional, persuasive or connective<br/></a></li>
      <li><a href="#numbers">Converting between numbers and words</a></li>
      <li><a href="#quantification">Quantification of numbers and lists</a> (e.g. 367 x chicken =
      hundreds of chickens)</li>
      <li><a href="#indefinite_article">Indefinite article: a or an</a></li>
      <li><a href="#pluralization">Pluralization/singularization of nouns</a></li>
      <li><a href="#emotional_value">Emotional value of a word</a></li>
      <li><a href="#WordNet">WordNet glossary, synonyms, antonyms, components</a></li>
      <li><a href="#verb_conjugation">Verb conjugation</a></li>
      <li><a href="#spelling">Spelling corrections</a></li>
      <li><a href="#shallow_parsing">Shallow parsing, the grammatical structure of a sentence</a></li>
      <li><a href="#summarisation">Summarisation of text to keywords</a></li>
      <li><a href="#rid">Regressive Imagery Dictionary, content analysis</a></li>
      <li><a href="#ogden">Ogden’s basic English words</a><br/></li>
    </ul>

    <p> </p>
    <hr/>

    <p><a id="loading_the_library" name="loading_the_library" title="loading_the_library"></a></p>
    <h2>How to get the library up and running</h2>

    <p>Put the <i>en</i> library folder in the same folder as your script so PlotDevice can find
    the library. You can also put it in <i>~/Library/Application Support/PlotDevice/.</i> It takes
    some time to load all the data the first time.</p>
<pre>
<span class="kn">import</span> <span class="nn">en</span>
</pre>

    <p> </p>
    <hr/>

    <p><a id="lexical_categorisation" name="lexical_categorisation" title="lexical_categorisation"></a></p>
    <h2>Categorise words as nouns, verbs, numbers and more</h2>

    <p>The <i>is_number()</i> command returns <i>True</i> when the given value is a number:</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>is_number(<span class="mi">12</span>)
<span class="k">print</span> en<span class="o">.</span>is_number(<span class="s">"twelve"</span>)
<span class="o">&gt;&gt;&gt;</span> <span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="bp">True</span>
</pre>

    <p>The <i>is_noun()</i> command returns <i>True</i> when the given string is a noun. You can
    also check for <i>is_verb()</i>, <i>is_adjective()</i> and <i>is_adverb()</i>:</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>is_noun(<span class="s">"banana"</span>)
<span class="o">&gt;&gt;&gt;</span> <span class="bp">True</span>
</pre>

    <p>The <i>is_tag()</i> command returns <i>True</i> when the given string is a tag, for example
    HTML or XML.</p>
    <p>The <i>is_html_tag()</i> command returns <i>True</i> when the string is a HTML tag.</p>
    <p> </p>
    <hr/>

    <p><a id="commonsense" name="commonsense" title="commonsense"></a></p>
    <h2>Categorise words as emotional, persuasive or connective</h2>

    <p>The <i>is_basic_emotion()</i> command returns <i>True</i> if the given word expresses a
    basic emotion (anger, disgust, fear, joy, sadness, surprise):</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>is_basic_emotion(<span class="s">"cheerful"</span>)
<span class="o">&gt;&gt;&gt;</span> <span class="bp">True</span>
</pre>

    <p>The <i>is_persuasive()</i> command returns <i>True</i> if the given word is a ‘magic’ word
    (you, money, save, new, results, health, easy, ...):</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>is_persuasive(<span class="s">"money"</span>)
<span class="o">&gt;&gt;&gt;</span> <span class="bp">True</span>
</pre>

    <p>The <i>is_connective()</i> command returns <i>True</i> if the word is a connective
    (nevertheless, whatever, secondly, ... and words like I, the, own, him which have little
    semantical value):</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>is_connective(<span class="s">"but"</span>)
<span class="o">&gt;&gt;&gt;</span> <span class="bp">True</span>
</pre>

    <p> </p>
    <hr/>

    <p><a id="numbers" name="numbers" title="numbers"></a></p>
    <h2>Converting between numbers and words</h2>

    <p>The <i>number.ordinal()</i> command returns the ordinal of the given number, 100 yields
    100th, 3 yields 3rd and twenty-one yields twenty-first:</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>number<span class="o">.</span>ordinal(<span class="mi">100</span>)
<span class="k">print</span> en<span class="o">.</span>number<span class="o">.</span>ordinal(<span class="s">"twenty-one"</span>)
<span class="o">&gt;&gt;&gt;</span> <span class="mi">100</span>th
<span class="o">&gt;&gt;&gt;</span> twenty<span class="o">-</span>first
</pre>

    <p>The <i>number.spoken()</i> command writes out the given number:</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>number<span class="o">.</span>spoken(<span class="mi">25</span>)
<span class="o">&gt;&gt;&gt;</span> twenty<span class="o">-</span>five
</pre>

    <p> </p>
    <hr/>

    <p><a id="quantification" name="quantification" title="quantification"></a></p>
    <h2>Quantification of numbers and lists</h2>

    <p>The <i>number.quantify()</i> command quantifies the given word:</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>number<span class="o">.</span>quantify(<span class="mi">10</span>, <span class="s">"chicken"</span>)
<span class="k">print</span> en<span class="o">.</span>number<span class="o">.</span>quantify(<span class="mi">800</span>, <span class="s">"chicken"</span>)
<span class="o">&gt;&gt;&gt;</span> a number of chickens
<span class="o">&gt;&gt;&gt;</span> hundreds of chickens
</pre>

    <p>The <i>list.conjunction()</i> command quantifies a list of words. Notice how goose is
    correctly pluralized and duck has the right article.</p>
<pre>farm <span class="o">=</span> [<span class="s">"goose"</span>, <span class="s">"goose"</span>, <span class="s">"chicken"</span>, <span class="s">"chicken"</span>, <span class="s">"chicken"</span>]
<span class="k">print</span> en<span class="o">.</span>list<span class="o">.</span>conjunction(farm)
<span class="o">&gt;&gt;&gt;</span> several chickens, a pair of geese <span class="ow">and</span> a duck
</pre>

    <p>You can also quantify the types of things in the given list, class or module:</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>list<span class="o">.</span>conjunction((<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>), generalize<span class="o">=</span><span class="bp">True</span>)
<span class="k">print</span> en<span class="o">.</span>list<span class="o">.</span>conjunction(en, generalize<span class="o">=</span><span class="bp">True</span>)
<span class="o">&gt;&gt;&gt;</span> several integers
<span class="o">&gt;&gt;&gt;</span> a number of modules, a number of functions, a number of strings, 
<span class="o">&gt;&gt;&gt;</span> a pair of lists, a pair of dictionaries, an en verb, an en sentence, 
<span class="o">&gt;&gt;&gt;</span> an en number, an en noun, an en <span class="nb">list</span>, an en content, an en adverb, 
<span class="o">&gt;&gt;&gt;</span> an en adjective, a <span class="bp">None</span> <span class="nb">type</span> <span class="ow">and</span> a plotdevice graphics cocoa <span class="nc">Context</span> <span class="k">class</span>
</pre>

    <p> </p>
    <hr/>

    <p><a id="indefinite_article" name="indefinite_article" title="indefinite_article"></a></p>
    <h2>Indefinite article: a or an</h2>

    <p>The <i>noun.article()</i> returns the noun with its indefinite article:</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>noun<span class="o">.</span>article(<span class="s">"university"</span>)
<span class="k">print</span> en<span class="o">.</span>noun<span class="o">.</span>article(<span class="s">"owl"</span>)
<span class="k">print</span> en<span class="o">.</span>noun<span class="o">.</span>article(<span class="s">"hour"</span>)
<span class="o">&gt;&gt;&gt;</span> a university
<span class="o">&gt;&gt;&gt;</span> an owl
<span class="o">&gt;&gt;&gt;</span> an hour
</pre>

    <p> </p>
    <hr/>

    <p><a id="pluralization" name="pluralization" title="pluralization"></a></p>
    <h2>Pluralization and singularization of nouns</h2>

    <p>The <i>noun.plural()</i> command pluralizes the given noun:</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>noun<span class="o">.</span>plural(<span class="s">"child"</span>)
<span class="k">print</span> en<span class="o">.</span>noun<span class="o">.</span>plural(<span class="s">"kitchen knife"</span>)
<span class="k">print</span> en<span class="o">.</span>noun<span class="o">.</span>plural(<span class="s">"wolf"</span>)
<span class="k">print</span> en<span class="o">.</span>noun<span class="o">.</span>plural(<span class="s">"part-of-speech"</span>)
<span class="o">&gt;&gt;&gt;</span> children
<span class="o">&gt;&gt;&gt;</span> kitchen knives
<span class="o">&gt;&gt;&gt;</span> wolves
<span class="o">&gt;&gt;&gt;</span> parts<span class="o">-</span>of<span class="o">-</span>speech
</pre>

    <p>You can also do <i>adjective.plural()</i>.</p>
    <p>An optional <i>classical</i> parameter is <i>True</i> by default and determines if either
    classical or modern inflection is used (e.g. classical pluralization of <i>octopus</i> yields
    <i>octopodes</i> instead of <i>octopuses</i>).</p>
    <p>The <i>noun.singular()</i> command singularizes the given plural:</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>noun<span class="o">.</span>singular(<span class="s">"people"</span>)
<span class="o">&gt;&gt;&gt;</span> person
</pre>

    <p> </p>
    <hr/>

    <p><a id="emotional_value" name="emotional_value" title="emotional_value"></a></p>
    <h2>Emotional value of a word</h2>

    <p>The <i>noun.is_emotion()</i> guesses whether the given noun expresses an emotion by checking
    if there are synonyms of the word that are basic emotions. Returns <i>True</i> or <i>False</i>
    by default.</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>noun<span class="o">.</span>is_emotion(<span class="s">"anger"</span>)
<span class="o">&gt;&gt;&gt;</span> <span class="bp">True</span>
</pre>

    <p>Or you can return a string which provides some information with the
    <i>boolean</i>=<i>False</i> parameter.</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>adjective<span class="o">.</span>is_emotion(<span class="s">"anxious"</span>, boolean<span class="o">=</span><span class="bp">False</span>)
<span class="o">&gt;&gt;&gt;</span> fear
</pre>

    <p>An additional optional parameter <i>shallow</i>=<i>True</i> speeds up the lookup process but
    doesn’t check as many synonyms. You can also use <i>verb.is_emotion()</i>,
    <i>adjective.is_emotion()</i> and <i>adverb.is_emotion()</i>.</p>
    <p> </p>
    <hr/>

    <p><a id="WordNet" name="WordNet" title="WordNet"></a></p>
    <h2>WordNet glossary, synonyms, antonyms, components</h2>

    <p>WordNet describes semantic relations between synonym sets.</p>
    <p>The <i>noun.gloss()</i> command returns the dictionary description of a word:</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>noun<span class="o">.</span>gloss(<span class="s">"book"</span>)
<span class="o">&gt;&gt;&gt;</span> a written work <span class="ow">or</span> composition that has been published (printed on pages 
<span class="o">&gt;&gt;&gt;</span> bound together); <span class="s">"I am reading a good book on economics"</span>
</pre>

    <p>A word can have multiple senses, for example ‘tree’ can mean a tree in a forest but also a
    tree diagram, or a person named Sir Herbert Beerbohm Tree:</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>noun<span class="o">.</span>senses(<span class="s">"tree"</span>)
<span class="o">&gt;&gt;&gt;</span> [[<span class="s">'tree'</span>], [<span class="s">'tree'</span>, <span class="s">'tree diagram'</span>], [<span class="s">'Tree'</span>, <span class="s">'Sir Beerbohm Tree'</span>]]
</pre>
<pre>
<span class="k">print</span> en<span class="o">.</span>noun<span class="o">.</span>gloss(<span class="s">"tree"</span>, sense<span class="o">=</span><span class="mi">1</span>)
<span class="o">&gt;&gt;&gt;</span> a figure that branches <span class="kn">from</span> <span class="nn">a</span> <span class="nn">single</span> <span class="nn">root</span>; <span class="s">"genealogical tree"</span>
</pre>

    <p>The <i>noun.lexname()</i> command returns a categorization for the given word:</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>noun<span class="o">.</span>lexname(<span class="s">"book"</span>)
<span class="o">&gt;&gt;&gt;</span> communication
</pre>

    <p>The <i>noun.hyponym()</i> command return examples of the given word:</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>noun<span class="o">.</span>hyponym(<span class="s">"vehicle"</span>)
<span class="o">&gt;&gt;&gt;</span> [[<span class="s">'bumper car'</span>, <span class="s">'Dodgem'</span>], [<span class="s">'craft'</span>], [<span class="s">'military vehicle'</span>], [<span class="s">'rocket'</span>, 
<span class="o">&gt;&gt;&gt;</span>  <span class="s">'projectile'</span>], [<span class="s">'skibob'</span>], [<span class="s">'sled'</span>, <span class="s">'sledge'</span>, <span class="s">'sleigh'</span>], [<span class="s">'steamroller'</span>, 
<span class="o">&gt;&gt;&gt;</span>  <span class="s">'road roller'</span>], [<span class="s">'wheeled vehicle'</span>]]
</pre>
<pre>
<span class="k">print</span> en<span class="o">.</span>noun<span class="o">.</span>hyponym(<span class="s">"tree"</span>, sense<span class="o">=</span><span class="mi">1</span>)
<span class="o">&gt;&gt;&gt;</span> [[<span class="s">'cladogram'</span>], [<span class="s">'stemma'</span>]]
</pre>

    <p>The <i>noun.hypernym()</i> command return abstractions of the given word:</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>noun<span class="o">.</span>hypernym(<span class="s">"earth"</span>)
<span class="k">print</span> en<span class="o">.</span>noun<span class="o">.</span>hypernym(<span class="s">"earth"</span>, sense<span class="o">=</span><span class="mi">1</span>)
<span class="o">&gt;&gt;&gt;</span> [[<span class="s">'terrestrial planet'</span>]]
<span class="o">&gt;&gt;&gt;</span> [[<span class="s">'material'</span>, <span class="s">'stuff'</span>]]
</pre>

    <p>You can also execute a deep query on hypernyms and hyponyms. Notice how returned values
    become more and more abstract:</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>noun<span class="o">.</span>hypernyms(<span class="s">"vehicle"</span>, sense<span class="o">=</span><span class="mi">0</span>)
<span class="o">&gt;&gt;&gt;</span> [[<span class="s">'vehicle'</span>], [<span class="s">'conveyance'</span>, <span class="s">'transport'</span>], 
<span class="o">&gt;&gt;&gt;</span>  [<span class="s">'instrumentality'</span>, <span class="s">'instrumentation'</span>], 
<span class="o">&gt;&gt;&gt;</span>  [<span class="s">'artifact'</span>, <span class="s">'artefact'</span>], [<span class="s">'whole'</span>, <span class="s">'unit'</span>], 
<span class="o">&gt;&gt;&gt;</span>  [<span class="s">'object'</span>, <span class="s">'physical object'</span>], 
<span class="o">&gt;&gt;&gt;</span>  [<span class="s">'physical entity'</span>], [<span class="s">'entity'</span>]]
</pre>

    <p>The <i>noun.holonym()</i> command returns components of the given word:</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>noun<span class="o">.</span>holonym(<span class="s">"computer"</span>)
<span class="o">&gt;&gt;&gt;</span> [[<span class="s">'busbar'</span>, <span class="s">'bus'</span>], [<span class="s">'cathode-ray tube'</span>, <span class="s">'CRT'</span>], 
<span class="o">&gt;&gt;&gt;</span>  [<span class="s">'central processing unit'</span>, <span class="s">'CPU'</span>, <span class="s">'C.P.U.'</span>, <span class="s">'central processor'</span>, 
<span class="o">&gt;&gt;&gt;</span>   <span class="s">'processor'</span>, <span class="s">'mainframe'</span>] <span class="o">...</span>
</pre>

    <p>The <i>noun.meronym()</i> command returns the collection in which the given word can be
    found:</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>noun<span class="o">.</span>meronym(<span class="s">"tree"</span>)
<span class="o">&gt;&gt;&gt;</span> [[<span class="s">'forest'</span>, <span class="s">'wood'</span>, <span class="s">'woods'</span>]]
</pre>

    <p>The <i>noun.antonym()</i> returns the semantic opposite of the word:</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>noun<span class="o">.</span>antonym(<span class="s">"black"</span>)
<span class="o">&gt;&gt;&gt;</span> [[<span class="s">'white'</span>, <span class="s">'whiteness'</span>]]
</pre>

    <p>Find out what two words have in common:</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>noun<span class="o">.</span>meet(<span class="s">"cat"</span>, <span class="s">"dog"</span>, sense1<span class="o">=</span><span class="mi">0</span>, sense2<span class="o">=</span><span class="mi">0</span>)
<span class="o">&gt;&gt;&gt;</span> [[<span class="s">'carnivore'</span>]]
</pre>

    <p>The <i>noun.absurd_gloss()</i> returns an absurd description for the word:</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>noun<span class="o">.</span>absurd_gloss(<span class="s">"typography"</span>)
<span class="o">&gt;&gt;&gt;</span> a business deal on a trivial <span class="nf">scale</span>
</pre>

    <p>The return value of a WordNet command is usually a list containing other lists of related
    words. You can use the <i>en.list.flatten()</i> command to flatten the list:</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>list<span class="o">.</span>flatten(en<span class="o">.</span>noun<span class="o">.</span>senses(<span class="s">"tree"</span>))
<span class="o">&gt;&gt;&gt;</span> [<span class="s">'tree'</span>, <span class="s">'tree'</span>, <span class="s">'tree diagram'</span>, <span class="s">'Tree'</span>, <span class="s">'Sir Herbert Beerbohm Tree'</span>]
</pre>

    <p>If you want a list of all nouns/verbs/adjectives/adverbs there’s the
    <i>wordnet.all_nouns()</i>, <i>wordnet.all_verbs()</i> ... commands:</p>
<pre>
<span class="k">print</span> <span class="nb">len</span>(en<span class="o">.</span>wordnet<span class="o">.</span>all_nouns())
<span class="o">&gt;&gt;&gt;</span> <span class="mi">117096</span>
</pre>

    <p>All of the commands shown here for nouns are also available for verbs, adjectives and
    adverbs, <i>en.verb.hypernyms(’run’)</i>, <i>en.adjective.gloss(’beautiful’)</i> etc. are valid
    commands.</p>
    <p> </p>
    <hr/>

    <p><a id="verb_conjugation" name="verb_conjugation" title="verb_conjugation"></a></p>
    <h2>Verb conjugation</h2>

    <p>PlotDevice English Linguistics knows the verb tenses for about 10000 English verbs.</p>
    <p>The <i>verb.infinitive()</i> command returns the infinitive form of a verb:</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>verb<span class="o">.</span>infinitive(<span class="s">"swimming"</span>)
<span class="o">&gt;&gt;&gt;</span> swim
</pre>

    <p>The <i>verb.present()</i> command returns the present tense for the given person. Known
    values for <i>person</i> are 1, 2, 3, ‘1st’, ‘2nd’, ‘3rd’, ‘plural’, ‘*’. Just use the one you
    like most.</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>verb<span class="o">.</span>present(<span class="s">"gave"</span>)
<span class="k">print</span> en<span class="o">.</span>verb<span class="o">.</span>present(<span class="s">"gave"</span>, person<span class="o">=</span><span class="mi">3</span>, negate<span class="o">=</span><span class="bp">False</span>)
<span class="o">&gt;&gt;&gt;</span> give
<span class="o">&gt;&gt;&gt;</span> gives
</pre>

    <p>The <i>verb.present_participle()</i> command returns the present participle tense:</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>verb<span class="o">.</span>present_participle(<span class="s">"be"</span>)
<span class="o">&gt;&gt;&gt;</span> being
</pre>

    <p>Return the past tense:</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>verb<span class="o">.</span>past(<span class="s">"give"</span>)
<span class="k">print</span> en<span class="o">.</span>verb<span class="o">.</span>past(<span class="s">"be"</span>, person<span class="o">=</span><span class="mi">1</span>, negate<span class="o">=</span><span class="bp">True</span>)
<span class="o">&gt;&gt;&gt;</span> gave
<span class="o">&gt;&gt;&gt;</span> wasn<span class="s">'t</span>
</pre>

    <p>Return the past participle tense:</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>verb<span class="o">.</span>past_participle(<span class="s">"be"</span>)
<span class="o">&gt;&gt;&gt;</span> been
</pre>

    <p>A list of all possible tenses:</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>verb<span class="o">.</span>tenses()
<span class="o">&gt;&gt;&gt;</span> [<span class="s">'past'</span>, <span class="s">'3rd singular present'</span>, <span class="s">'past participle'</span>, <span class="s">'infinitive'</span>, 
<span class="o">&gt;&gt;&gt;</span>  <span class="s">'present participle'</span>, <span class="s">'1st singular present'</span>, <span class="s">'1st singular past'</span>, 
<span class="o">&gt;&gt;&gt;</span>  <span class="s">'past plural'</span>, <span class="s">'2nd singular present'</span>, <span class="s">'2nd singular past'</span>, 
<span class="o">&gt;&gt;&gt;</span>  <span class="s">'3rd singular past'</span>, <span class="s">'present plural'</span>]
</pre>

    <p>The <i>verb.tense()</i> command returns the tense of the given verb:</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>verb<span class="o">.</span>tense(<span class="s">"was"</span>)
<span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span>st singular past
</pre>

    <p>Return <i>True</i> if the given verb is in the given tense:</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>verb<span class="o">.</span>is_tense(<span class="s">"wasn't"</span>, <span class="s">"1st singular past"</span>, negated<span class="o">=</span><span class="bp">True</span>)
<span class="k">print</span> en<span class="o">.</span>verb<span class="o">.</span>is_present(<span class="s">"does"</span>, person<span class="o">=</span><span class="mi">1</span>)
<span class="k">print</span> en<span class="o">.</span>verb<span class="o">.</span>is_present_participle(<span class="s">"doing"</span>)
<span class="k">print</span> en<span class="o">.</span>verb<span class="o">.</span>is_past_participle(<span class="s">"done"</span>)
<span class="o">&gt;&gt;&gt;</span> <span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="bp">False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="bp">True</span>
</pre>

    <p>The verb.is_tense() command also accepts shorthand aliases for tenses: <i>inf</i>,
    <i>1sgpres</i>, <i>2gpres</i>, <i>3sgpres</i>, <i>pl</i>, <i>prog</i>, <i>1sgpast</i>,
    <i>2sgpast</i>, <i>3sgpast</i>, <i>pastpl</i> and <i>ppart</i>.</p>
    <hr/>

    <h2><a id="spelling" name="spelling" title="spelling"></a>Spelling corrections</h2>

    <p>PlotDevice English Linguistics is able to perform spelling corrections based on Peter
    Norvig’s algorithm. The spelling corrector has an accuracy of about 70%.</p>
    <p>The <i>spelling.suggest()</i> returns a list of possible corrections for a given word. The
    <i>spelling.correct()</i> command returns the corrected version (best guess) of the word.</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>spelling<span class="o">.</span>suggest(<span class="s">"comptuer"</span>)
<span class="o">&gt;&gt;&gt;</span> [<span class="s">'computer'</span>]
</pre>    
    <hr/>

    <p><a id="shallow_parsing" name="shallow_parsing" title="shallow_parsing"></a></p>
    <h2>Shallow parsing, the grammatical structure of a sentence</h2>

    <p>PlotDevice English Linguistics is able to do sentence structure analysis using a combination
    of Jason Wiener’s tagger and NLTK’s chunker. The tagger assigns a part-of-speech tag to each
    word in the sentence using a (Brill’s) lexicon. A <i>postag</i> is something like NN or VBP
    marking words as nouns, verbs, determiners, pronouns, etc. The chunker is then able to group
    syntactic units in the sentence. A syntactic unit is, for example, a determiner followed by
    adjectives followed by a noun: <i>the tasty little chicken</i> is a syntactic unit.</p>
    <p>The <i>sentence.tag()</i> command tags the given sentence. The return value is a list of
    <i>(word, tag)</i> tuples. However, when you print it out it will look like a string.</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>sentence<span class="o">.</span>tag(<span class="s">"this is so cool"</span>)
<span class="o">&gt;&gt;&gt;</span> this<span class="o">/</span>DT <span class="ow">is</span><span class="o">/</span>VBZ so<span class="o">/</span>RB cool<span class="o">/</span>JJ
</pre>

    <p>There are lots of part-of-speech tags and it takes some time getting to know them. The full
    list is <a href="Linguistics/part_of_speech_tags.html">here</a>. The
    <i>sentence.tag_description()</i> returns a <i>(description, examples)</i> tuple for a given
    tag:</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>sentence<span class="o">.</span>tag_description(<span class="s">"NN"</span>)
<span class="o">&gt;&gt;&gt;</span> (<span class="s">'noun, singular or mass'</span>, <span class="s">'tiger, chair, laughter'</span>)
</pre>

    <p>The <i>sentence.chunk()</i> command returns the chunked sentence:</p>
<pre>
<span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> pprint
pprint( en<span class="o">.</span>sentence<span class="o">.</span>chunk(<span class="s">"we are going to school"</span>) )
<span class="o">&gt;&gt;&gt;</span> [[<span class="s">'SP'</span>,
<span class="o">&gt;&gt;&gt;</span>   [<span class="s">'NP'</span>, (<span class="s">'we'</span>, <span class="s">'PRP'</span>)],
<span class="o">&gt;&gt;&gt;</span>   [<span class="s">'AP'</span>,
<span class="o">&gt;&gt;&gt;</span>   [<span class="s">'VP'</span>, (<span class="s">'are'</span>, <span class="s">'VBP'</span>), (<span class="s">'going'</span>, <span class="s">'VBG'</span>), (<span class="s">'to'</span>, <span class="s">'TO'</span>)],
<span class="o">&gt;&gt;&gt;</span>   [<span class="s">'NP'</span>, (<span class="s">'school'</span>, <span class="s">'NN'</span>)]]]]
</pre>

    <p>Now what does all this mean?</p>
    <ul>
      <li><b>NP</b>: noun phrases, syntactic units describing a noun, for example: a big fish.</li>
      <li><b>VP</b>: verb phrases, units of verbs and auxillaries, for example: are going to.</li>
      <li><b>AP</b>: a verb/argument structure, a verb phrase and a noun phrase being influenced.</li>
      <li><b>SP</b>: a subject structure: a noun phrase which is the executor of a verb phrase or
      verb/argument structure.</li>
    </ul>

    <p>A handy <i>sentence.traverse(sentence, cmd)</i> command lets you feed a chunked sentence to
    your own command chunk by chunk:</p>
<pre>s <span class="o">=</span> <span class="s">"we are going to school"</span>
<span class="k">def</span> <span class="nf">callback</span>(chunk, token, tag):
    <span class="k">if</span> chunk <span class="o">!=</span> <span class="bp">None</span> : 
        <span class="k">print</span> en<span class="o">.</span>sentence<span class="o">.</span>tag_description(chunk)[<span class="mi">0</span>]<span class="o">.</span>upper()
    <span class="k">if</span> chunk <span class="o">==</span> <span class="bp">None</span> : 
        <span class="k">print</span> token, <span class="s">"("</span><span class="o">+</span>en<span class="o">.</span>sentence<span class="o">.</span>tag_description(tag)[<span class="mi">0</span>]<span class="o">+</span><span class="s">")"</span>
en<span class="o">.</span>sentence<span class="o">.</span>traverse(s, callback)
<span class="o">&gt;&gt;&gt;</span> SUBJECT PHRASE
<span class="o">&gt;&gt;&gt;</span> NOUN PHRASE
<span class="o">&gt;&gt;&gt;</span> we (pronoun, personal)
<span class="o">&gt;&gt;&gt;</span> VERB PHRASE AND ARGUMENTS
<span class="o">&gt;&gt;&gt;</span> VERB PHRASE
<span class="o">&gt;&gt;&gt;</span> are (verb, non<span class="o">-</span><span class="mi">3</span>rd person singular present)
<span class="o">&gt;&gt;&gt;</span> going (verb, gerund <span class="ow">or</span> present participle)
<span class="o">&gt;&gt;&gt;</span> to (infinitival to)
<span class="o">&gt;&gt;&gt;</span> NOUN PHRASE
<span class="o">&gt;&gt;&gt;</span> school (noun, singular <span class="ow">or</span> mass)
</pre>

    <p>A even handier <i>sentence.find(sentence, pattern)</i> command lets you find patterns of
    text in a sentence:</p>
<pre>s <span class="o">=</span> <span class="s">"The world is full of strange and mysterious things."</span>
<span class="k">print</span> en<span class="o">.</span>sentence<span class="o">.</span>find(s, <span class="s">"JJ and JJ NN"</span>)
<span class="o">&gt;&gt;&gt;</span> [[(<span class="s">'strange'</span>, <span class="s">'JJ'</span>), (<span class="s">'and'</span>, <span class="s">'CC'</span>), 
<span class="o">&gt;&gt;&gt;</span>   (<span class="s">'mysterious'</span>, <span class="s">'JJ'</span>), (<span class="s">'things'</span>, <span class="s">'NNS'</span>)]]
</pre>

    <p>The returned list contains all chunks of text that matched the pattern. In the example above
    it retrieved all chunks of the form <i>an adjective + and + an adjective + a noun</i>. Notice
    that when you use something like ‘NN’ in your pattern (noun), NNS (plural nouns) are returned
    as well.</p>
<pre>s <span class="o">=</span> <span class="s">"The hairy hamsters visited the cruel dentist."</span>
matches <span class="o">=</span> en<span class="o">.</span>sentence<span class="o">.</span>find(s, <span class="s">"JJ NN"</span>)
<span class="k">print</span> matches
<span class="o">&gt;&gt;&gt;</span> [[(<span class="s">'hairy'</span>, <span class="s">'JJ'</span>), (<span class="s">'hamsters'</span>, <span class="s">'NNS'</span>)], 
     [(<span class="s">'cruel'</span>, <span class="s">'JJ'</span>), (<span class="s">'dentist'</span>, <span class="s">'NN'</span>)]]
</pre>

    <p>An optional <i>chunked</i> parameter can be set to <i>False</i> to return strings instead of
    token/tag tuples. You can put pieces of the pattern between brackets to make them optional, or
    use wildcards:</p>
<pre>s <span class="o">=</span> <span class="s">"This makes the parser an extremely powerful tool."</span>
<span class="k">print</span> en<span class="o">.</span>sentence<span class="o">.</span>find(s, <span class="s">"(extreme*) (JJ) NN"</span>, chunked<span class="o">=</span><span class="bp">False</span>)
<span class="o">&gt;&gt;&gt;</span> [<span class="s">'parser'</span>, <span class="s">'extremely powerful tool'</span>]
</pre>

    <p>Finally, if you feel up to it you could feed the following command with a list of your own
    regular expression units to chunk, mine are pretty basic as I’m not a linguist.</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>sentence<span class="o">.</span>chunk_rules()
</pre>

    <p> </p>
    <hr/>

    <p><a id="summarisation" name="summarisation" title="summarisation"></a></p>
    <h2>Summarisation of text to keywords</h2>

    <p>PlotDevice English Linguistics is able to strip keywords from a given text.</p>
<pre>en<span class="o">.</span>content<span class="o">.</span>keywords(txt, top<span class="o">=</span><span class="mi">10</span>, nouns<span class="o">=</span><span class="bp">True</span>, singularize<span class="o">=</span><span class="bp">True</span>, filters<span class="o">=</span>[])
</pre>

    <p>The <i>content.keywords()</i> command guesses a list of words that frequently occur in the
    given text. The return value is a list (length defined by top) of <i>(count, word)</i> tuples.
    When <i>nouns</i> is <i>True</i>, returns only nouns. The command furthermore ignores
    connectives, numbers and tags. When <i>singularize</i> is <i>True</i>, attempts to singularize
    nouns in the text. The optional <i>filters</i> parameter is a list of words which the command
    should ignore.</p>
    <p>So, assuming you would want to summarise web content you can do the following:</p>
<pre>
<span class="kn">from</span> <span class="nn">urllib</span> <span class="kn">import</span> urlopen
html <span class="o">=</span> urlopen(<span class="s">"http://news.bbc.co.uk/"</span>)<span class="o">.</span>read()
meta <span class="o">=</span> [<span class="s">"news"</span>, <span class="s">"health"</span>, <span class="s">"uk"</span>, <span class="s">"version"</span>, <span class="s">"weather"</span>, 
        <span class="s">"video"</span>, <span class="s">"sport"</span>, <span class="s">"return"</span>, <span class="s">"read"</span>, <span class="s">"help"</span>]
<span class="k">print</span> sentence_keywords(html, filters<span class="o">=</span>meta)
<span class="o">&gt;&gt;&gt;</span> [(<span class="mi">6</span>, <span class="s">'funeral'</span>), (<span class="mi">5</span>, <span class="s">'beirut'</span>), (<span class="mi">3</span>, <span class="s">'war'</span>), (<span class="mi">3</span>, <span class="s">'service'</span>), (<span class="mi">3</span>, <span class="s">'radio'</span>), 
<span class="o">&gt;&gt;&gt;</span>  (<span class="mi">3</span>, <span class="s">'lebanon'</span>), (<span class="mi">3</span>, <span class="s">'islamist'</span>), (<span class="mi">3</span>, <span class="s">'function'</span>), (<span class="mi">3</span>, <span class="s">'female'</span>)]
</pre>

    <p> </p>
    <hr/>

    <h2><a id="rid" name="rid" title="rid"></a>Regressive Imagery Dictionary, psychological content
    analysis</h2>

    <p>PlotDevice English Linguistics is able to do psychological content analysis using John
    Wiseman’s Python implementation of the Regressive Imagery Dictionary. The RID asigns scores to
    <i>primary</i>, <i>secondary</i> and <i>emotional</i> process thoughts in a text.</p>
    <ul>
      <li>Primary: free-form associative thinking involved in dreams and fantasy</li>
      <li>Secondary: logical, reality-based and focused on problem solving</li>
      <li>Emotions: expressions of fear, sadness, hate, affection, etc.</li>
    </ul>
<pre>en<span class="o">.</span>content<span class="o">.</span>categorise(<span class="nb">str</span>)
</pre>

    <p>The <i>content.categorise()</i> command returns a sorted list of categories found in the
    text. Each item in the list has the following properties:</p>
    <ul>
      <li><i>item.name</i>: the name of the category</li>
      <li><i>item.count</i>: the number of words in the text that fall into this category</li>
      <li><i>item.words</i>: a list of words from the text that fall into this category</li>
      <li><i>item.type</i>: the type of category, either ‘primary’, ‘secondary’ or ‘emotions’.</li>
    </ul>

    <p>Let’s run a little test with Lucas’ <a href="Keywords/Ideas_from_the_Heart.html">Ideas from
    the Heart</a> text:<br/></p>
<pre>txt <span class="o">=</span> <span class="nb">open</span>(<span class="s">"heart.txt"</span>)<span class="o">.</span>read()
summary <span class="o">=</span> en<span class="o">.</span>content<span class="o">.</span>categorise(txt)
<span class="k">print</span> summary<span class="o">.</span>primary
<span class="k">print</span> summary<span class="o">.</span>secondary
<span class="k">print</span> summary<span class="o">.</span>emotions
<span class="o">&gt;&gt;&gt;</span> <span class="mf">0.290155440415</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mf">0.637305699482</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mf">0.0725388601036</span>
<span class="c"># Lucas' text has a 64% secondary value.</span>
</pre>
<pre>
<span class="c"># The top 5 categories in the text:</span>
<span class="k">for</span> category <span class="ow">in</span> summary[:<span class="mi">5</span>]:
    <span class="k">print</span> category<span class="o">.</span>name, category<span class="o">.</span>count
<span class="o">&gt;&gt;&gt;</span> instrumental behavior <span class="mi">30</span>
<span class="o">&gt;&gt;&gt;</span> abstraction <span class="mi">30</span>
<span class="o">&gt;&gt;&gt;</span> social behavior <span class="mi">28</span>
<span class="o">&gt;&gt;&gt;</span> temporal references <span class="mi">24</span>
<span class="o">&gt;&gt;&gt;</span> concreteness <span class="mi">18</span>
</pre>
<pre>
<span class="c"># Words in the top "instrumental behavior" category:</span>
<span class="k">print</span> summary[<span class="mi">0</span>]<span class="o">.</span>words
<span class="o">&gt;&gt;&gt;</span> [<span class="s">'students'</span>, <span class="s">'make'</span>, <span class="s">'students'</span>, <span class="s">'reached'</span>, <span class="s">'countless'</span>, 
<span class="o">&gt;&gt;&gt;</span>  <span class="s">'student'</span>, <span class="s">'workshop'</span>, <span class="s">'workshop'</span>, <span class="s">'students'</span>, <span class="s">'finish'</span>, 
<span class="o">&gt;&gt;&gt;</span>  <span class="s">'spent'</span>, <span class="s">'produce'</span>, <span class="s">'using'</span>, <span class="s">'work'</span>, <span class="s">'students'</span>, <span class="s">'successful'</span>, 
<span class="o">&gt;&gt;&gt;</span>  <span class="s">'workshop'</span>, <span class="s">'students'</span>, <span class="s">'pursue'</span>, <span class="s">'skills'</span>, <span class="s">'use'</span>, 
<span class="o">&gt;&gt;&gt;</span>  <span class="s">'craftsmanship'</span>, <span class="s">'use'</span>, <span class="s">'using'</span>, <span class="s">'workshops'</span>, <span class="s">'workshops'</span>, 
<span class="o">&gt;&gt;&gt;</span>  <span class="s">'result'</span>, <span class="s">'students'</span>, <span class="s">'workshops'</span>, <span class="s">'student'</span>]
</pre>

    <p>You can find all the categories for primary, secondary and emotional scores in the
    <i>en.rid.primary</i>, <i>en.rid.secondary</i> and <i>en.rid.emotions</i> lists.</p>
    <p> </p>
    <p> </p>
    <hr size="2" width="100%"/>

    <p> </p>
    <h2><a id="ogden" name="ogden" title="ogden"></a>Ogden’s basic English words</h2>

    <p>PlotDevice English Linguistics comes bundled with Charles K. Ogden list of basic English
    words: a set of 2000 words that can express 90% of the concepts in English. The list is stored
    as <i>en.basic.words</i>. It can be filtered for <i>nouns</i>, <i>verbs</i>, <i>adjectives</i>
    and <i>adverbs</i>:</p>
<pre>
<span class="k">print</span> en<span class="o">.</span>basic<span class="o">.</span>words
<span class="o">&gt;&gt;&gt;</span> [<span class="s">'a'</span>, <span class="s">'able'</span>, <span class="s">'about'</span>, <span class="s">'account'</span>, <span class="s">'acid'</span>, <span class="s">'across'</span>, <span class="o">...</span> ]
</pre>
<pre>
<span class="k">print</span> en<span class="o">.</span>basic<span class="o">.</span>verbs
<span class="o">&gt;&gt;&gt;</span> [<span class="s">'account'</span>, <span class="s">'act'</span>, <span class="s">'air'</span>, <span class="s">'amount'</span>, <span class="s">'angle'</span>, <span class="s">'answer'</span>, <span class="o">...</span> ]
</pre><br/>
  </div>

</body></html>