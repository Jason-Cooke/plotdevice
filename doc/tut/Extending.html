<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>

  <title>PlotDevice Tutorials: Extending</title>
  <link charset="utf-8" href="../etc/manual.css" rel="stylesheet" type="text/css"/>

</head><body>
  <div class="link" id="nav">
    <h1><a href="../manual.html">Plot Device <span>Tutorials</span></a></h1>

    <h3>Extending Plot Device</h3>

    <ul class="chapter">
      <li><a href="Scripting.html">Scripting →</a></li>
      <li>Chapter 17</li>
      <li><a href="Math.html">← Math</a></li>
    </ul>
  </div>

  <div class="article">
    <p>PlotDevice is built on <a href="http://pyobjc.sourceforge.net/">PyObjC</a>, a bridge between
    the Python and Objective-C programming languages. The primary usage of PyObjC is writing
    <a href="http://developer.apple.com/cocoa/">Cocoa</a> applications for Mac OS X in pure python.
    Cocoa is the programming environment on Mac OS X that allows developers to create graphical
    applications with a typical Apple-look-and-feel.</p>
    <p>Cocoa’s two main libraries (<em>Foundation Kit</em> and <em>Application Kit</em>) are
    bundled with PlotDevice. If you know a little PyObjC it’s easy to start playing around with all
    the magic in Mac OS X, right from your PlotDevice script.</p>
    <p class="pink_text"><em>This tutorial contains advanced material.</em></p>
    <hr/>

    <h2>AppKit manual</h2>

    <p>The first thing you’ll notice about AppKit is that it has a <em>lot</em> of <em>long</em>
    and <em>odd</em> objects all beginning with <em>NS</em>: NSBezierPath, NSRect, NSImage, and so
    on (the <em>NS</em> stems from the fact that AppKit is a direct descendant of NeXTSTEP, Steve
    Jobs’ technology that revived Apple).</p>
    <p>Commands like <em>layoutManager.drawGlyphsForGlyphRange_atPoint_(glyphRange,
    (x-dx,y-dy-self.font.defaultLineHeightForFont()))</em> are common. So the first thing to do is
    get a manual. If you’ve installed Xcode, it provides a totally reasonable documentation viewer
    accessible through the Help menu. On the web you can find Apple’s <a href="https://developer.apple.com/library/mac/documentation/cocoa/reference/applicationkit/objc_classic/_index.html">
    AppKit</a> &amp; <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/ObjC_classic/_index.html">
    Foundation</a> references.</p>
    <hr/>

    <h2>AppKit rules of thumb</h2>

    <p>Apple’s documentation lists all of the objects in their Objective-C form. To use them in
    Python, a good rule of thumb is to <strong>replace the colon with an underscore</strong> (e.g.
    <em>setShadowBlurRadius:(float)val</em> becomes <em>setShadowBlurRadius_(floatval)</em> ).</p>
    <p>Another good thing to know is that you create AppKit objects with <em>object.alloc()</em>
    and then initialise them with <em>object.init()</em> or
    <em>object.initWithARangeOfParamaters()</em>.</p>
    <p>Also note that some things that are in Foundation like NSSize or NSRect can usually be
    substituted by simple Python tuples.</p>
    <p>To start using AppKit in PlotDevice simply import the library:</p>
<pre>
<span class="kn">from</span> <span class="nn">Appkit</span> <span class="kn">import</span> <span class="o">*</span>
</pre>

    <p>I’ll show you some examples of what you can do with AppKit.</p>
    <hr/>

    <h2>Playing sounds in PlotDevice</h2>

    <p>The NSSound object in AppKit provides a very easy way to play AIFF and WAV sound files in
    Mac applications. The class below is a PlotDevice wrapper for NSSound.</p>
<pre>
<span class="kn">from</span> <span class="nn">AppKit</span> <span class="kn">import</span> NSSound
 
<span class="k">class</span> <span class="nc">sound</span>:
    <span class="k">def</span> <span class="nf">__init__</span>(<span class="bp">self</span>, <span class="nb">file</span>):
        <span class="bp">self</span><span class="o">.</span>_sound <span class="o">=</span> NSSound<span class="o">.</span>alloc()
        <span class="bp">self</span><span class="o">.</span>_sound<span class="o">.</span>initWithContentsOfFile_byReference_(<span class="nb">file</span>, <span class="bp">True</span>)
    <span class="k">def</span> <span class="nf">play</span>(<span class="bp">self</span>): <span class="bp">self</span><span class="o">.</span>_sound<span class="o">.</span>play()
    <span class="k">def</span> <span class="nf">stop</span>(<span class="bp">self</span>): <span class="bp">self</span><span class="o">.</span>_sound<span class="o">.</span>stop()
    <span class="k">def</span> <span class="nf">is_playing</span>(<span class="bp">self</span>): <span class="k">return</span> <span class="bp">self</span><span class="o">.</span>_sound<span class="o">.</span>isPlaying()
</pre>

    <p>As you can see our <em>sound()</em> command takes a <em>file</em> parameter (that is the
    location of your sound file) and returns an object with a number of properties:</p>
    <ul>
      <li><em>sound.play()</em>: start playing the sound</li>
      <li><em>sound.stop()</em>: stop playing</li>
      <li><em>sound.is_playing()</em>: returns True when playing</li>
    </ul>
<pre>woof <span class="o">=</span> sound(<span class="s">"dog.aiff"</span>)
woof<span class="o">.</span>play()
</pre>

    <p>The following class defines a simple sound mixer/timeline. It has a number of channels that
    play sounds at a defined time.</p>
<pre>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> time
 
<span class="k">class</span> <span class="nc">mixer</span>:   
    <span class="k">def</span> <span class="nf">__init__</span>(<span class="bp">self</span>, channels<span class="o">=</span><span class="mi">4</span>):
        <span class="bp">self</span><span class="o">.</span>channels <span class="o">=</span> [[] <span class="k">for</span> i <span class="ow">in</span> <span class="nb">range</span>(channels)]
        <span class="bp">self</span><span class="o">.</span>start <span class="o">=</span> time()
        <span class="bp">self</span><span class="o">.</span>playing <span class="o">=</span> []
    <span class="k">def</span> <span class="nf">queue</span>(<span class="bp">self</span>, channel, time, <span class="nb">file</span>):
        <span class="bp">self</span><span class="o">.</span>channels[channel]<span class="o">.</span>append( (time, sound(<span class="nb">file</span>)) )
        <span class="bp">self</span><span class="o">.</span>channels[channel]<span class="o">.</span>sort()
    <span class="k">def</span> <span class="nf">play</span>(<span class="bp">self</span>):
        now <span class="o">=</span> time() <span class="o">-</span> <span class="bp">self</span><span class="o">.</span>start
        <span class="k">for</span> ch <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span>channels:
            <span class="k">if</span> <span class="nb">len</span>(ch) <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> ch[<span class="mi">0</span>][<span class="mi">0</span>] <span class="o">&lt;</span> now:
                <span class="bp">self</span><span class="o">.</span>playing<span class="o">.</span>append(ch[<span class="mi">0</span>][<span class="mi">1</span>])
                ch[<span class="mi">0</span>][<span class="mi">1</span>]<span class="o">.</span>play()
                <span class="k">del</span> ch[<span class="mi">0</span>]
    <span class="k">def</span> <span class="nf">stop</span>(<span class="bp">self</span>):
        <span class="k">for</span> sound <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span>playing:
            sound<span class="o">.</span>stop()
        <span class="bp">self</span><span class="o">.</span>playing <span class="o">=</span> []
        <span class="bp">self</span><span class="o">.</span>channels <span class="o">=</span> [[] <span class="k">for</span> ch <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span>channels]
</pre>

    <p>Queueing multiple sounds is now very easy:<br/></p>
<pre>m <span class="o">=</span> mixer(<span class="mi">2</span>)
m<span class="o">.</span>queue(<span class="mi">0</span>, <span class="mf">0.0</span>, <span class="s">"woof.aiff"</span>)
m<span class="o">.</span>queue(<span class="mi">0</span>, <span class="mf">0.4</span>, <span class="s">"woof.aiff"</span>)
m<span class="o">.</span>queue(<span class="mi">0</span>, <span class="mf">0.8</span>, <span class="s">"woof.aiff"</span>)
m<span class="o">.</span>queue(<span class="mi">0</span>, <span class="mf">1.2</span>, <span class="s">"woof.aiff"</span>)
m<span class="o">.</span>queue(<span class="mi">1</span>, <span class="mf">0.4</span>, <span class="s">"meow.aiff"</span>)
m<span class="o">.</span>queue(<span class="mi">1</span>, <span class="mf">1.2</span>, <span class="s">"meow.aiff"</span>)
</pre>

    <p> </p>
    <hr/>

    <h2>BabbleBox: speech synthesis in PlotDevice</h2>

    <p>The example below wraps the NSSpeechSynthesizer in two PlotDevice commands. The
    <em>voices()</em> command returns a list of all available voices. The <em>say()</em> command
    makes PlotDevice speak out a sentence. The optional <em>voice</em> parameter sets the voice you
    want to use.<br/></p>
<pre>
<span class="kn">from</span> <span class="nn">AppKit</span> <span class="kn">import</span> NSSpeechSynthesizer
 
<span class="k">def</span> <span class="nf">voices</span>():
    voices <span class="o">=</span> NSSpeechSynthesizer<span class="o">.</span>availableVoices()
    voices <span class="o">=</span> [x<span class="o">.</span>split(<span class="s">"."</span>)[<span class="o">-</span><span class="mi">1</span>] <span class="k">for</span> x <span class="ow">in</span> voices]
    <span class="k">return</span> voices
    
<span class="k">def</span> <span class="nf">say</span>(txt, voice<span class="o">=</span><span class="bp">None</span>):
    <span class="k">if</span> voice <span class="ow">in</span> voices():
        voice <span class="o">=</span> <span class="s">"com.apple.speech.synthesis.voice."</span><span class="o">+</span>voice
    <span class="k">else</span>:
        voice <span class="o">=</span> NSSpeechSynthesizer<span class="o">.</span>defaultVoice()
    speech <span class="o">=</span> NSSpeechSynthesizer<span class="o">.</span>alloc()<span class="o">.</span>initWithVoice_(voice)
    speech<span class="o">.</span>startSpeakingString_(txt)
</pre>

    <p>Now say <em>hello</em> in a random voice:</p>
<pre>say(<span class="s">"hello"</span>, voice<span class="o">=</span><span class="nf">choice</span>(voices()))
</pre><br/>
    <hr/>

    <h2>All the fonts on your system</h2>

    <p>The command below wraps the NSFontManager object. It returns a list with the PostScript name
    of each font installed on your system. Thanks to Mark for this one.</p>
<pre>
<span class="kn">from</span> <span class="nn">AppKit</span> <span class="kn">import</span> NSFontManager
 
<span class="k">def</span> <span class="nf">fonts</span>():
    <span class="k">return</span> NSFontManager<span class="o">.</span>sharedFontManager()<span class="o">.</span>availableFonts()
</pre>

    <p>Now you can do lots of fun typography:</p>
<pre>
<span class="nf">background</span>(<span class="mf">0.15</span>, <span class="mf">0.1</span>, <span class="mf">0.1</span>)
 
x, y, h <span class="o">=</span> <span class="mi">0</span>, <span class="mi">0</span>, <span class="mi">0</span>
<span class="nf">lineheight</span>(<span class="mi">1</span>)
<span class="nf">fontsize</span>(<span class="mi">14</span>)
<span class="k">for</span> f <span class="ow">in</span> <span class="nf">fonts</span>()[:<span class="mi">250</span>]:
 
    <span class="nf">font</span>(f)
 
    <span class="c"># Random pink, blue or white color </span>
    <span class="nf">fill</span>(<span class="nf">random</span>(), <span class="nf">random</span>(<span class="mf">0.5</span>), <span class="mf">0.75</span>)
    <span class="k">if</span> <span class="nf">random</span>() <span class="o">&gt;</span> <span class="mf">0.8</span>: <span class="nf">fill</span>(<span class="mi">1</span>)
    
    <span class="c"># Wrap text to the next line </span>
    <span class="k">if</span> x <span class="o">+</span> <span class="nf">textwidth</span>(f) <span class="o">&gt;</span> <span class="kc">WIDTH</span>:
        x <span class="o">=</span> <span class="mi">0</span>
        y <span class="o">+=</span> h
        h <span class="o">=</span> <span class="mi">0</span>
 
    <span class="nf">text</span>(f, x, y)
 
    <span class="c"># Line height is equal to biggest font </span>
    h <span class="o">=</span> <span class="nb">max</span>(h, <span class="nf">textheight</span>(f))
    x <span class="o">+=</span> <span class="nf">textwidth</span>(f)
</pre>

    <p><img alt="pyobjc-fonts" height="550" src="../etc/tut/pyobjc-fonts.jpg" width="550"/><br/></p>
    <p> </p>
    <hr/>

    <h2>Dashed lines</h2>

    <p>Obviously all of the commands in PlotDevice are wrappers to AppKit calls. In most cases you
    can still manipulate them directly with PyObjC. For example, a BezierPath object has a
    <em>path</em> property containing the actual NSBezierPath. This we can manipulate to create
    some custom effects.<br/></p>
<pre>
<span class="k">def</span> <span class="nf">linedash</span>(path, segment<span class="o">=</span><span class="mi">10</span>, gap<span class="o">=</span><span class="mi">5</span>):
    path<span class="o">.</span>path<span class="o">.</span>setLineDash_count_phase_([segment, gap], <span class="mi">2</span>, <span class="mi">0</span>)
    <span class="k">return</span> path
</pre>
<pre>p <span class="o">=</span> <span class="nf">line</span>(<span class="mi">0</span>, <span class="mi">0</span>, <span class="mi">200</span>, <span class="mi">200</span>, draw<span class="o">=</span><span class="bp">False</span>)
linedash(p, segment<span class="o">=</span><span class="mi">5</span>)
<span class="nf">stroke</span>(<span class="mi">0</span>)
<span class="nf">drawpath</span>(p)
</pre>

    <p><img alt="pyobjc-linedash" height="214" src="../etc/tut/pyobjc-linedash.jpg" width="222"/><br/></p>
    <p> </p>
    <hr/>

    <h2>Dropshadows in PlotDevice</h2>

    <p>Here I create a wrapper for NSShadow. The result are two commands, <em>shadow()</em> and
    <em>noshadow()</em> that work like <a href="../ref/Line+Color.html#fill()">fill()</a> and
    <a href="../ref/Line+Color.html#nofill()">nofill()</a>: every drawing command defined after
    <em>shadow()</em> will have a dropshadow until you call <em>noshadow()</em>.</p>
    <p>Note that the shadow class inherits from something called <em>Grob</em>. This is short for
    <em>Graphic Object</em>. A Grob executes its <em>_draw()</em> method the moment it is drawn.
    You need to initialise it with the current context (canvas) to draw in, that’s why we pass the
    global <em>_ctx</em> to Grob.__init__(). The <em>_ctx</em> contains the current context.</p>
    <p>This is a typical example of what PlotDevice drawing commands look like (also see the
    <a href="http://dev.nodebox.net/browser/plotdevice/trunk/src/DrawingPrimitives.py">source</a>).</p>
<pre>
<span class="kn">from</span> <span class="nn">AppKit</span> <span class="kn">import</span> NSShadow, NSColor
<span class="kn">from</span> <span class="nn">plotdevice.graphics</span> <span class="kn">import</span> <span class="nc">Grob</span>
 
<span class="k">class</span> <span class="nc">shadow</span>(<span class="nc">Grob</span>):
    <span class="k">def</span> <span class="nf">__init__</span>(<span class="bp">self</span>, x<span class="o">=</span><span class="mi">10</span>, y<span class="o">=</span><span class="mi">10</span>, alpha<span class="o">=</span><span class="mf">0.25</span>, blur<span class="o">=</span><span class="mf">4.0</span>):
        <span class="nc">Grob</span><span class="o">.</span>__init__(<span class="bp">self</span>, _ctx)
        <span class="bp">self</span><span class="o">.</span>_shadow <span class="o">=</span> NSShadow<span class="o">.</span>alloc()<span class="o">.</span>init()
        <span class="bp">self</span><span class="o">.</span>_shadow<span class="o">.</span>setShadowOffset_((x, <span class="o">-</span>y))
        <span class="bp">self</span><span class="o">.</span>_shadow<span class="o">.</span>setShadowColor_(<span class="nf">color</span>(<span class="mi">0</span>, <span class="mi">0</span>, <span class="mi">0</span>, alpha)<span class="o">.</span>_rgb)
        <span class="bp">self</span><span class="o">.</span>_shadow<span class="o">.</span>setShadowBlurRadius_(blur)
        <span class="bp">self</span><span class="o">.</span>draw()
    <span class="k">def</span> <span class="nf">_draw</span>(<span class="bp">self</span>):
        <span class="bp">self</span><span class="o">.</span>_shadow<span class="o">.</span>set()
        
<span class="k">def</span> <span class="nf">noshadow</span>():
    shadow(alpha<span class="o">=</span><span class="mi">0</span>)
</pre>

    <p>Shadows work very well to create a feeling of depth:<br/></p>
<pre>shadow(blur<span class="o">=</span><span class="mf">10.0</span>)
 
<span class="k">for</span> i <span class="ow">in</span> <span class="nb">range</span>(<span class="mi">30</span>):
    <span class="nf">fill</span>(<span class="nf">random</span>(<span class="mf">0.75</span>), <span class="mi">0</span>, <span class="nf">random</span>(<span class="mf">0.25</span>,<span class="mf">0.75</span>))
    r <span class="o">=</span> <span class="nf">random</span>(<span class="mi">50</span>)
    <span class="nf">oval</span>(<span class="nf">random</span>(<span class="kc">WIDTH</span>), <span class="nf">random</span>(<span class="kc">HEIGHT</span>), r, r)
</pre> 

    <p><img alt="pybobjc-shadow" height="397" src="../etc/tut/pyobjc-shadow1.jpg" width="396"/></p>
    <p> </p>
    <p><img alt="pyobjc-shadow2" height="296" src="../etc/tut/pyobjc-shadow2.jpg" width="298"/><br/></p>
  </div>

</body></html>